



10월 11일
1. 포인터는 주소를 저장하고 주소를 이용해서 값을 출력하거나 수정하는 등의 기능을 할 수 있다.
2. -> 의 경우 포인터를 지칭하는것이고 . 의 경우 바로 클래스 멤버 변수를 지칭하는것이다.
3. 포인터도 변수이기때문에 주소를 가지고 있다.
4. 구조체의 경우 사용하고 싶은 자료형과 변수를 저장해놓고 사용자가 필요한것에 맞춰서 사용하면 된다.
5. C++의 클래스의경우 구현부 선언부 출력부가 있는데 프로젝트가 클 경우 클래스에 맞게 각각 따로 구현할 수 있다.

10월 12일
1. 클래스는 구조체에서 파생된것이다.
2. 클래스는 기본 접근제한자가 private이고 구조체는 public이다.
3. 메인함수 아래 함수를 선언할경우 사용하기 위해서 ㅁ메인함수 위에 선언부를 따로 만들어야 한다.

10월 13일
1. SVN 커밋전에 항상 업데이트 먼저 진행해야한다.

10월 16일
1. 생성자는 객체를 생성할 때 자동으로 호출되는 함수고, 소멸자는 객체가 소멸될 때 자동으로 호출되는 함수다.
2. 생성자와 소멸자는 다양한 기능을 하는데 생성자는 객체가 잘 동작할수 있도록 준비 하는 일이고 소멸자는 정리하는 작업이라고 보면된다.
3. 컴퓨터에 메모리 영역은 Code, Data, Stack, Heap 영역이 있는데 일반 지역변수와 매개변수경우 스택에 저장되고 동적메모리 할당 경우 힙 메모리에 저장된다. 동적 메모리의 경우에는 프로그래머직접 생성하고 지워야 하지만 메모레를 가변적으로 사용할 수 있는 장점이 있다.

10월 18일
1. const 속성을 가진 변수, 참조 변수의 경우는 반드시 초기화 되어야 하는 공통점이 있다. const의 경우 일단 정의하고 나면 변경이 불가능 하기 때문에 반드시 초기화를 해야한다. 레퍼런스 변수의 경우에는 처음에정의할 때를 제외하고는 다른 변수를 참조하게 만들 수 없기 때문에 반드시 초기화 해야한다.

10월 30일
싱글톤 패턴이란?
소프트웨어 디자인 패턴에서 싱글턴 패턴(Singleton pattern)을 따르는 클래스는, 생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나이고 최초 생성 이후에 호출된 생성자는 최초의 생성자가 생성한 객체를 리턴한다. 이와 같은 디자인 유형을 싱글턴 패턴이라고 한다. 주로 공통된 객체를 여러개 생성해서 사용하는 DBCP(DataBase Connection Pool)와 같은 상황에서 많이 사용된다.

11월 2일
1. call by reference, call by value, call by address

11월 6일
callbyaddress 에서 함수의 매개변수를 int* address로 선언하고 main 에서 함수를 호출할때 인자값을 &a로 지정하면 a의 주소값이 address로 저장되기 때문에 
*address값을 변경하면 a 의 값도 변경된다.
callbyreference의 경우 함수 인자 &refernece 에 인자값 a를 받으면 a가 할단된 메모리를 공유받게 된다.
즉 a를 함수 안에서는 reference로 부르겠다는 말이다.

포인터 변수의 경우주소값을 가지는 변수로 메모리 공간에 4바이트를 차지한다.
하지만 레퍼런스 변수의 경우 메모리공간을 차지하지 않고 원본 변수의 별명으로 서 붙어버린다.

========================

오버로딩의 경우 함수 중복 정의로 같은 이름의 함수이지만 매개변수를 다르게 정의하여 매개변수에 따라 함수가 다르게 실행된다.
오버라이딩의 경우 상속 개념으로 부모클래스의 함수를 사용하지 않고 다른 기능을 실행할 때 함수를 자식클래스에 같은 이름, 매개변수로 재정의 해서 사용한다.

오버로드를 이용하여 생성자를 효율적으로 사용할 수도있다.
생성자의 경우 멤버변수를 초기화 해주는데 오버로드를 이용해서 파라미터에 다른 초기값을 설정해줄 수 있다.

=========================
const속성을 가진 타입이나 레퍼런스 ㅏㅌ입의 멤버변수를 초기화할 수 있다.
반드시 초기화해야 하는 멤버 변수들은 생성자의 초기화 리스트를 사용해서 초기화 한다.
초기화 리스트는 생성자의 소괄호와 중괄호 사이에 위치한다.

1월 23일
swich case 문 안에서 break가 없으면 조건실행부터 default 까지 절차적으로 전부 실행된다.

1월 29일
char *p = "KOREA" 이란 문자열 포인터 p에 korea가 저장된 주소번지를 저장하는 의미이다.
임의 100번지 주소에 KOREA를 저장한것.
배열로 문자열 저장하는 방법은
char arr[5] = "KOREA"

2월 7일
헤더에 구조체를 선언하고 구조체 멤버변수에 값을 원하는 크기만큼 데이터를 원하는 자료형으로 넣기 위해서  unsigned 자료형 같은 식으로 
선언을 해야하고 main함수에다가 구조체 변수를 선언을 할때 입력 받은 데이터를 reinterpret_cast로 형변환을 해야한다.
포인터의 경우랑 일반 변수의 경우 형변환 하는 방법이 다르다. 일반의 경우 static_cast로 진행을 하고 구조체 변수에 접근할때.을 통해서
접근하고 포인터의 경우 -> 를 이용해서 접근해야한다.

2월 8일
빅 엔디안과 리틀 엔디안은 2바이트 이상의 크기를 가진 변수가 메모리에 자리잡는 방식에 따라서 구분된다. 0x12345678을 int 타입의 변수에
메모리에 저장될때 리틀 엔디안의 경우 0x78,0x56,0x34,0x12 식으로 왼쪽부터 낮은 주소로 저장된다.
빅엔디안의 경우 낮은 주소에 0x12가 저장된다.

2월 13일
const 사용 이유는 다른곳에 변수의 값을 제공하기는 하지만 그곳에서 읽기만 할 수 있을 뿐, 변수의 값을 바꿀 수는 없게 만들고 싶을 때 사용할 
수 있다.
const를 사용해서 변수를 정의할 때는 반드시 초기화 해줘야 한다.
const unsigned int arraySize = 100;
char characters[arraySize] = {0};
이 부분에서 개발도중 배열의 크기가 변경될경우 arraySize 만 변경 해주면 된다.
